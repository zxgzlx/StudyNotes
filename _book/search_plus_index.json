{"./":{"url":"./","title":"Introduction","keywords":"","body":"记录一些东西吧 你所经历的每一次事故、不幸和挫折，实际上都是一个潜在的美妙机会，只是它们未以真面目示人，且永远对你的成功和快乐充满信心。 关于 生活还是需要点激情和鼓励的。 目录 互联网学习 JS相关知识 js闭包相关知识 js中this相关知识 TypeScript基础语法 js中宽松等价与严格等价 js中XHR和fetch 浏览器js执行部分原理 chrome开发者调试工具 游戏开发相关知识 Cocos v2.0.9新API 缓动系统 cc.tween 了解 websocket简单介绍 设计模式 设计模式-概况kotlin实现 设计模式1-单例模式 设计模式2-工厂模式 设计模式3-观察者模式 设计模式4-建造者模式 设计模式5-代理模式 设计模式6-策略模式 设计模式7-适配器模式 Python相关知识 RESTful理解 Java相关知识 移动开发相关知识 跨平台移动框架介绍 算法和数据结构 js数据结构和算法--数组 js数据结构与算法--栈 js数据结构与算法--队列和双端队列 js数据结构与算法--链表 js数据结构与算法--链表（二） js数据结构与算法--树（一） js数据结构与算法--排序算法（一） js数据结构与算法--搜索算法 js数据结构与算法--图 其他 VPS搭建 Markdown 常用语法 电影 电影推荐 电影影评 读书笔记 心理学 理财、财经 文学、畅销类 外语学习 生活 回到顶部 "},"notes/js设计模式-单例.html":{"url":"notes/js设计模式-单例.html","title":"设计模式","keywords":"","body":"单例模式 它是指在一个类只能有一个实例，即使多次实例化该类，也只返回第一次实例化后的实例对象。单例模式不仅能减少不必要的内存开销, 并且在减少全局的函数和变量冲突也具有重要的意义。 对象字面量创建单例 let foo = { name: \"哈哈\", bar: function (name) {this.name = name} } foo.bar(); // 全局就一个foo,出发对象被覆盖，可以通过const不允许此对象字面量不被覆盖 惰性单例 // 懒汉式，调用的时候才实例唯一一个实例 let foo = (function() { let _instance = null; function instance() { this.name = \"haha\" } return function() { if (!_instance) { _instance = new instance(); } return _instance; } })(); let foo1 = foo(); let foo2 = foo(); console.log(foo1 === foo2); //true 通过ES6，可以更清晰和简洁，而且更容易理解和使用单例，下面学习ES6中的使用。 ES6中的单例模式 不构建单例 class Foo { constructor(name) { this.name = name; } } let foo1 = new Foo(\"foo1\"); let foo2 = new Foo(\"foo2\"); // 多次new会生成多个对象 构建单例 // 构造函数中实现单例，饿汉式 class Foo { constructor(name) { this.name = name; if (!Foo.instance) { // 把this赋值到instance中去 Foo.instance = this; } return Foo.instance; } } let foo1 = new Foo(\"foo1\"); let foo2 = new Foo(\"foo2\"); console.log(foo1 === foo2); //true // 优化上述代码，使用静态方法获取实例，懒汉式 class Foo { constructor(name) { this.name = name; } // 静态方法 static getInstance(name) { if (!this.instance) { this.instance = new Foo(name); } return this.instance; } } let foo1 = new Foo(\"foo1\"); let foo2 = new Foo(\"foo2\"); console.log(foo1 === foo2); //true 总结 使用地方，比如登陆的时候，只能生成一个实例。还有其它等地方全局只使用一个实例，比如通过单例模式进行命名空间来解决全局变量的冲突，使用管理模块让结构更加清晰，减少内存开销等。 "},"notes/设计模式2-工厂模式.html":{"url":"notes/设计模式2-工厂模式.html","title":"设计模式2-工厂模式","keywords":"","body":"设计模式2-工厂模式 什么是工厂模式 不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。 分类 简单工厂 工厂方法 抽象工厂 举例说明 假如你开一家商店，要去工厂订一批货，你不需要知道怎么生产货，你只要拿到你说出要的货，工厂就能给你了。所以说你调用货的时候只要说出名字，工厂就能给你相应的货。 简单工厂 简单工厂模式又叫静态工厂模式，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。 let FruitFactory = function(fruit){ function Fruit(fruitName){ this.name = fruitName; } switch(fruit){ case 'apple': return new Fruit('苹果'); case 'banana': return new Fruit('香蕉'); case 'orange': return new Fruit('橘子'); default: throw new Error('参数不正确'); } } // 调用 let apple = FruitFactory('apple'); let banana = FruitFactory('banaba'); let orange = FruitFactory('orange'); 工厂模式 工厂方法模式的本意是将实际创建对象的工作推迟到子类中，这样核心类就变成了抽象类。 // 安全模式创建的工厂方法函数 let FruitFactory = function(fruit){ if(this instanceof FruitFactory){ let s = new this[fruit](); return s; } else { return new FruitFactory(fruit); } } // 工厂方法函数的原型中设置所以对象的构造函数 FruitFactory.prototype = { Apple: function(){ this.name = '苹果' } Banana: function(){ this.name = '香蕉' } Orange: function(){ this.name = '橘子' } } // 调用 let apple = FruitFactory('Apple'); let banana = FruitFactory('Banaba'); let orange = FruitFactory('Orange'); 抽象工厂 上面介绍了简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建。 let AccountAbstractFactory = function(subType, superType) { //判断抽象工厂中是否有该抽象类 if(typeof AccountAbstractFactory[superType] === 'function') { //缓存类 function F() {}; //继承父类属性和方法 F.prototype = new AccountAbstractFactory[superType] (); //将子类的constructor指向子类 subType.constructor = subType; //子类原型继承父类 subType.prototype = new F(); } else { throw new Error('抽象类不存在!') } } //微信用户抽象类 AccountAbstractFactory.WechatUser = function() { this.type = 'wechat'; } AccountAbstractFactory.WechatUser.prototype = { getName: function() { return new Error('抽象方法不能调用'); } } //qq用户抽象类 AccountAbstractFactory.QqUser = function() { this.type = 'qq'; } AccountAbstractFactory.QqUser.prototype = { getName: function() { return new Error('抽象方法不能调用'); } } //新浪微博用户抽象类 AccountAbstractFactory.WeiboUser = function() { this.type = 'weibo'; } AccountAbstractFactory.WeiboUser.prototype = { getName: function() { return new Error('抽象方法不能调用'); } } // 定义普通用户的子类 //普通微信用户子类 function UserOfWechat(name) { this.name = name; this.viewPage = ['首页', '通讯录', '发现页'] } //抽象工厂实现WechatUser类的继承 AccountAbstractFactory(UserOfWechat, 'WechatUser'); //子类中重写抽象方法 UserOfWechat.prototype.getName = function() { return this.name; } //普通qq用户子类 function UserOfQq(name) { this.name = name; this.viewPage = ['首页', '通讯录', '发现页'] } //抽象工厂实现QqUser类的继承 AccountAbstractFactory(UserOfQq, 'QqUser'); //子类中重写抽象方法 UserOfQq.prototype.getName = function() { return this.name; } //普通微博用户子类 function UserOfWeibo(name) { this.name = name; this.viewPage = ['首页', '通讯录', '发现页'] } //抽象工厂实现WeiboUser类的继承 AccountAbstractFactory(UserOfWeibo, 'WeiboUser'); //子类中重写抽象方法 UserOfWeibo.prototype.getName = function() { return this.name; } //实例化微信用户 let wechatUserA = new UserOfWechat('微信小李'); console.log(wechatUserA.getName(), wechatUserA.type); //微信小李 wechat let wechatUserB = new UserOfWechat('微信小王'); console.log(wechatUserB.getName(), wechatUserB.type); //微信小王 wechat //实例化qq用户 let qqUserA = new UserOfQq('QQ小李'); console.log(qqUserA.getName(), qqUserA.type); //QQ小李 qq let qqUserB = new UserOfQq('QQ小王'); console.log(qqUserB.getName(), qqUserB.type); //QQ小王 qq //实例化微博用户 let weiboUserA =new UserOfWeibo('微博小李'); console.log(weiboUserA.getName(), weiboUserA.type); //微博小李 weibo let weiboUserB =new UserOfWeibo('微博小王'); console.log(weiboUserB.getName(), weiboUserB.type); //微博小王 weibo ES6中的工厂模式 // 重写简单工厂 class Fruit{ constructor(fruitName){ this.name = fruitName; } // 静态方法 static getInstance(fruit){ switch(fruit){ case 'apple': return new Fruit('apple'); case 'banana': return new Fruit('banana'); case 'orange': return new Fruit('orange'); default: throw new Error('参数错误'); } } } //调用 let apple = User.getInstance('apple'); let banana = User.getInstance('banana'); let orange = User.getInstance('orange'); // 重写工厂方法 class Fruit{ constuctor(name){ if(new.target === Fruit){ throw new Error('抽象类不能实例化'); } this.name = name; } } class FruitFactory extends Fruit{ constructor(name){ super(name); } create(fruit){ switch(fruit){ case 'apple': return new FruitFactory('apple'); case 'banana': return new FruitFactory('banana'); case 'orange': return new FruitFactory('orange'); default: throw new Error('参数错误'); } } } // 调用 let fruitFactory = new FruitFactory(); let apple = fruitFactory.create('apple'); let banana = fruitFactory.create('banana'); let orange = fruitFactory.create('orange'); // 重写抽象方法 class User { constructor(type) { if (new.target === User) { throw new Error('抽象类不能实例化!') } this.type = type; } } class UserOfWechat extends User { constructor(name) { super('wechat'); this.name = name; this.viewPage = ['首页', '通讯录', '发现页'] } } class UserOfQq extends User { constructor(name) { super('qq'); this.name = name; this.viewPage = ['首页', '通讯录', '发现页'] } } class UserOfWeibo extends User { constructor(name) { super('weibo'); this.name = name; this.viewPage = ['首页', '通讯录', '发现页'] } } function getAbstractUserFactory(type) { switch (type) { case 'wechat': return UserOfWechat; break; case 'qq': return UserOfQq; break; case 'weibo': return UserOfWeibo; break; default: throw new Error('参数错误, 可选参数:superAdmin、admin、user') } } let WechatUserClass = getAbstractUserFactory('wechat'); let QqUserClass = getAbstractUserFactory('qq'); let WeiboUserClass = getAbstractUserFactory('weibo'); let wechatUser = new WechatUserClass('微信小李'); let qqUser = new QqUserClass('QQ小李'); let weiboUser = new WeiboUserClass('微博小李'); "},"notes/设计模式3-观察者模式.html":{"url":"notes/设计模式3-观察者模式.html","title":"设计模式3-观察者模式","keywords":"","body":"观察者模式 举例：就那间谍来说。我方和假象敌，我方派多个间谍打入到假象敌内部，当假象敌内部情报发生变化，间谍们就会获取情报做出相应的行为。这种一个假象敌（观察目标，亦叫被观察者）对应一堆间谍（观察者）的模式，一对多的依赖关系，从而一个对象变化影响其他对象。 定义： 观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。 观察者模式概述 观察者模式层次结构图: Subject（目标，被观察者）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以抽象类或具体类。 ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。 Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。 ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。 观察者模式描述了如何建立对象与对象之间的依赖关系，以及如何构造满足这种需求的系统。观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。作为对这个通知的响应，每个观察者都将监视观察目标的状态以使其状态与目标状态同步，这种交互也称为发布-订阅(Publish-Subscribe)。观察目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。 除举例部分是自己的见解，上面概述部分引用自下面的作者 作者：Liuwei-Sunny 来源：CSDN 原文：https://blog.csdn.net/LoveLion/article/details/7720382 看看ES6部分怎么实现观察这模式 下面实现一个事件的发布和订阅的过程: // observer-pattern.js /* * @Author: zx * @Date: 2019-04-27 10:04:16 * @Last Modified by: zx * @Last Modified time: 2019-04-27 10:08:16 */ // 思路就是按照订阅者按照事件类型在发布者中注册，相同类型的回调函数推到发布者分配的数组里面，当发布者发布消息是，发布者数组的的回调函数会触发，订阅者就会随之改变。 class PubSub { constructor() { // 事件处理函数集合 this.handles = {}; } // 订阅模式 on(eventType, handle) { if (!this.handles.hasOwnProperty(eventType)) { this.handles[eventType] = []; } if (typeof handle === 'function') { this.handles[eventType].push(handle); } else { throw new Error('不是回调函数'); } return this; // 实现链式操作 } // 发布事件 emit(eventType, ...args){ if (this.handles.hasOwnProperty(eventType)) { this.handles[eventType].forEach((item, index, arr) => { item.apply(null, args); }); } else { throw new Error('\"${eventType}\"事件未注册'); } return this; // 实现链式操作 } // 删除事件 off(eventType, handle){ console.log() if (!this.handles.hasOwnProperty(eventType)){ throw new Error('\"${eventType}\"事件未注册'); } else if (typeof handle !== 'function'){ throw new Error('不是回调函数'); } else { this.handles[eventType].forEach((item, index, arr) => { if (item === handle) arr.splice(index, 1); }); } return this; // 实现链式操作 } } let callback = function(){ console.log('you are so nice'); }; let pubSub = new PubSub(); pubSub.on('completed', (...args)=>{ console.log(args.join(' ')); }).on('completed', callback); pubSub.emit('completed', 'Are', 'you', 'ok!'); pubSub.off('completed', callback); pubSub.emit('completed', 'Hello,', 'Mi', 'fans'); 通过node.js运行此脚本,需要安装node.js环境: $ node observer-pattern.js 运行结果： Are you ok! you are so nice Hello, Mi fans 在实际项目中，比如现在正在做的小游戏中的消息就用到了观察者模式，服务推过来的数据发生变化时，所有UI的数据就会相应的变化和更新，这里服务器推过来的数据相当于发布者（被观察者），UI相当于订阅者（观察者），UI按照事件类型进行注册，服务器按照事件类型进行通知，UI在他们的通知后进行数据更新，UI在不需要的时候将取消服务器的注册。这整个流程其实就观察者模式的实现，其实叫发布订阅模式更好理解。 "},"notes/设计模式4-建造者模式.html":{"url":"notes/设计模式4-建造者模式.html","title":"设计模式4-建造者者模式","keywords":"","body":"建造者模式 建造者模式的概念 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。 建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。它关注如何一步一步创建一个的复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。 举例 就拿捕鱼类的游戏来说吧，涉及到炮台的成长。随着游戏的推进，会逐渐拥有新的炮台，而且不同类型的炮台的皮肤、技能等都不同。所有玩家获得炮台，都会包括这些，它们是由各个部件组装而成，比如炮台底座，皮肤，技能等组装成完整的炮台，这就是建造者模式需要解决的问题。建造者模式又称为生成器模式，它是一种较为复杂、使用频率也相对较低的创建型模式。建造者模式为客户端返回的不是一个简单的产品，而是一个由多个部件组成的复杂产品。 建造者模式结构图大致如下： Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。 ●ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。 ●Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。 ● Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。 相关文字说明引用自下面链接： 作者：Liuwei-Sunny 来源：CSDN 原文：https://blog.csdn.net/lovelion/article/details/7426015 版权声明：本文为博主原创文章，转载请附上博文链接！ 建造者模式的构建思路 建造者模式的特点是分步构建一个复杂的对象，可以用不同组合或顺序建造出不同意义的对象，通常使用者并不需要知道建造的细节，通常使用链式调用来进行建造过程，最后调用build方法来生成最终对象。 与工厂模式的区别 同样作为创建型的设计模式，需要注意和工厂模式的区别，工厂虽然也是创建对象，但怎样创建无所谓，工厂模式关注的是创建的结果；而建造者模式不仅得到了结果，同时也参与了创建的具体过程，适合用来创建一个复杂的复合对象。 ES6中实现建造者模式 实现一个实例 //书籍建造者类 class BookBuilder { constructor() { this.name = ''; this.author = ''; this.price = 0; this.category = ''; } withName(name) { this.name = name; return this; } withAuthor(author) { this.author = author; return this; } withPrice(price) { this.price = price; return this; } withCategory(category) { this.category = category; return this; } build() { return { name: this.name, author: this.author, prices: this.price, category: this.category } } } //调用建造者类 const book = new BookBuilder() .withName(\"高效能人士的七个习惯\") .withAuthor('史蒂芬·柯维') .withPrice(51) .withCategory('励志') .build(); 优化 //书籍建造者类 class BookBuilder { constructor() { this.name = ''; this.author = ''; this.price = 0; this.category = ''; Object.keys(this).forEach(key => { const withName = `with${key.substring(0, 1).toUpperCase()}${key.substring(1)}`; this[withName] = value => { this[key] = value; return this; } }) } //调用建造者 build() { const keysNoWithers = Object.keys(this).filter(key => typeof this[key] !== 'function'); return keysNoWithers.reduce((returnValue, key) => { return { ...returnValue, [key]: this[key] } }, {}) } } const book = new BookBuilder() .withName(\"高效能人士的七个习惯\") .withAuthor('史蒂芬·柯维') .withPrice(51) .withCategory('励志') .build(); 上面的BookBuilder这个类和第一个例子的效果一样，但是长度确减少不少，在有更多属性的时候，减少的代码量会更为明显。我们将所有的建造方法withxxxx在constructor调用时自动被创建，这里我们使用了一些ES6的新语法：Object.keys获取对象属性数组，...的合并对象的语法。 虽然该写法在阅读起来会比第一个方法难以理解，但是这样写法的真正作用在于，当我们需要许多的建造者类时，我们可以将上面自动创建withxxx和build的代码提取为一个父类。在创建其他建造者类时继承该父类，这使得在创建多个建造者类时变得十分容易。 //父类 class BaseBuilder { init() { Object.keys(this).forEach(key => { const withName = `with${key.substring(0, 1).toUpperCase()}${key.substring(1)}`; this[withName] = value => { this[key] = value; return this; } }) } build() { const keysNoWithers = Object.keys(this).filter(key => typeof this[key] !== 'function'); return keysNoWithers.reduce((returnValue, key) => { return { ...returnValue, [key]: this[key] } }, {}) } } //子类1: 书籍建造者类 class BookBuilder extends BaseBuilder { constructor() { super(); this.name = ''; this.author = ''; this.price = 0; this.category = ''; super.init(); } } //子类2: 印刷厂建造者类 class printHouseBuilder extends BaseBuilder { constructor() { super(); this.name = ''; this.location = ''; this.quality = ''; super.init(); } } //调用书籍建造者类 const book = new BookBuilder() .withName(\"高效能人士的七个习惯\") .withAuthor('史蒂芬·柯维') .withPrice(51) .withCategory('励志') .build(); //调用印刷厂建造类 const printHouse = new printHouseBuilder() .withName('新华印刷厂') .withLocation('北京海淀区') .withQuality('A') .build(); 总结 在之前提到的几种工厂模式中，他们都有一个共同特点，就是对象的创建过程不得而知，我们在调用一个函数后返回了最终的结果对象。但是在创建者模式中我们关心的是对象的创建过程，我们通常将创建复杂对象的各个类模块化，在ES6中，我们采用import和export的语法可以很灵活的引用和导出这些模块进行我们的建造模式最终生成一个结果对象。 可以看出，建造者模式的使用有且只适合创建极为复杂的对象。在前端的实际业务中，在没有这类极为复杂的对象的创建时，还是应该直接使用对象字面或工厂模式等方式创建对象。 "},"notes/设计模式5-代理模式.html":{"url":"notes/设计模式5-代理模式.html","title":"设计模式5-代理模式","keywords":"","body":"代理模式 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 Java中实现 // Image.java public interface Image { void display(); } // RealImage.java public class RealImage implements Image { private String fileName; public RealImage(String fileName){ this.fileName = fileName; loadFromDisk(fileName); } @Override public void display() { System.out.println(\"Displaying \" + fileName); } private void loadFromDisk(String fileName){ System.out.println(\"Loading \" + fileName); } } // ProxyImage.java public class ProxyImage implements Image{ private RealImage realImage; private String fileName; public ProxyImage(String fileName){ this.fileName = fileName; } @Override public void display() { if(realImage == null){ realImage = new RealImage(fileName); } realImage.display(); } } // ProxyPatternDemo.java // 当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。 public class ProxyPatternDemo { public static void main(String[] args) { Image image = new ProxyImage(\"test_10mb.jpg\"); // 图像将从磁盘加载 image.display(); System.out.println(\"\"); // 图像不需要从磁盘加载 image.display(); } } // 运行结果 Loading test_10mb.jpg Displaying test_10mb.jpg Displaying test_10mb.jpg ES6中的具体对应新增对象Proxy MDN定义： Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。 let p = new Proxy(target, handler); target是你要代理的对象.它可以是JavaScript中的任何合法对象.如: (数组, 对象, 函数等等) handler是你要自定义操作方法的一个集合. p是一个被代理后的新对象,它拥有target的一切属性和方法.只不过其行为和结果是在handler中自定义的. let obj = { a: 1, b: 2, } const p = new Proxy(obj, { get(target, key) { if (key === 'c') { return '我是自定义的一个结果'; } else { return target[key]; } }, set(target, key, value) { if (value === 4) { target[key] = '我是自定义的一个结果'; } else { target[key] = value; } } }) console.log(obj.a) // 1 console.log(obj.c) // undefined console.log(p.a) // 1 console.log(p.c) // 我是自定义的一个结果 obj.name = '李白'; console.log(obj.name); // 李白 obj.age = 4; console.log(obj.age); // 4 p.name = '李白'; console.log(p.name); // 李白 p.age = 4; console.log(p.age); // 我是自定义的一个结果 通过上面的get和set方法，重定义了属性的读取（get）和设置（set）行为,Proxy 实际上重载（overload）了get和set方法，即用自己的定义覆盖了语言的原始定义。我们把Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是obj对象）进行操作。 考虑到get和set方法，可以通过JavaScript的反射进行表单属性拦截验证，这个下次再填坑吧，顺便了解JavaScript中的反射Reflect对象的使用方法。 "}}